user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log  warn;
pid        /var/run/nginx.pid;

events {
  worker_connections 1024;
}

http {
  include       /etc/nginx/mime.types;
  default_type  application/octet-stream;

  log_format main
    '$remote_addr - $remote_user [$time_local] "$request" '
    '$status $body_bytes_sent "$http_referer" '
    '"$http_user_agent" "$http_x_forwarded_for" '
    'location:$sent_http_location';

  access_log  /var/log/nginx/access.log  main;

  sendfile           on;
  tcp_nopush         on;
  tcp_nodelay        on;
  keepalive_timeout  65;
  types_hash_max_size 2048;
  client_max_body_size 100M;

  # DNS do Docker (otimizado - sem IPv6 para melhor performance)
  resolver 127.0.0.11 valid=30s ipv6=off;
  resolver_timeout 5s;

  # WebSocket
  map $http_upgrade $connection_upgrade { default upgrade; '' close; }

  # Gzip (TURBINADA: comp_level otimizado)
  gzip on;
  gzip_vary on;
  gzip_comp_level 6;  # TURBINADA: ⬆️ de 1 para 6 (-40% transferência)
  gzip_min_length 1024;
  gzip_proxied expired no-cache no-store private auth;
  gzip_types
    text/plain
    text/css
    text/xml
    text/javascript
    application/x-javascript
    application/xml+rss
    application/javascript
    application/json;

  # Upstreams (nomes dos serviços do Compose)
  # TURBINADA: keepalive aumentado (64 de 32) + timeout otimizado
  upstream ai_gateway_upstream { 
    server ai-gateway:8080; 
    keepalive 64;  # TURBINADA: ⬆️ pool de conexões
    keepalive_timeout 60s;
    keepalive_requests 1000;
  }
  upstream dashboard_upstream  { 
    server dashboard:8501;  
    keepalive 32;  # TURBINADA: adicionar keepalive
    keepalive_timeout 60s;
  }
  upstream grafana_upstream    { 
    server grafana:3000;    
    keepalive 32;  # TURBINADA: adicionar keepalive
    keepalive_timeout 60s;
  }

  server {
    listen       80;
    listen       [::]:80;
    server_name  localhost;

    # Evita Nginx reescrever Location como absoluto
    absolute_redirect off;

    # ---------- Health Check ----------
    location /health {
      return 200 'OK';
      add_header Content-Type text/plain;
    }

    # ---------- Dashboard (raiz) ----------
    location / {
      proxy_pass http://dashboard_upstream;
      proxy_set_header Host              $host;
      proxy_set_header X-Real-IP         $remote_addr;
      proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }

    # ---------- AI Gateway ----------
    location /api/ {
      proxy_pass http://ai_gateway_upstream/;
      proxy_http_version 1.1;
      proxy_set_header Upgrade           $http_upgrade;
      proxy_set_header Connection        $connection_upgrade;
      proxy_set_header Host              $host;
      proxy_set_header X-Real-IP         $remote_addr;
      proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }

    # ---------- Grafana em /grafana/ ----------
    # /grafana (sem barra) -> redireciona UMA vez para /grafana/
    location = /grafana {
      return 302 /grafana/;
    }

    # /grafana/ e todos os subcaminhos -> proxy para o container
    # FIX: removida a barra final do proxy_pass para preservar o path completo
    location /grafana/ {
      proxy_http_version 1.1;
      proxy_set_header Host               $host;
      proxy_set_header X-Real-IP          $remote_addr;
      proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto  $scheme;
      proxy_set_header X-Forwarded-Host   $host;
      proxy_set_header X-Forwarded-Prefix /grafana;
      proxy_cookie_path /grafana /grafana/;
      proxy_cookie_path /       /grafana/;

      proxy_redirect off;
      # CORREÇÃO: SEM barra final - Grafana recebe /grafana/ intacto
      proxy_pass http://grafana_upstream;
    }
  }
}
