#!/usr/bin/env python3
# -- coding: utf-8 --
"""
Bot Runner Modular - Vers√£o refatorada com arquitetura modular
Mant√©m 100% compatibilidade com bot_runner.py original
Inclui instrumenta√ß√£o Prometheus slot-aware
"""

import os
import sys
import time
import re
import redis
import threading
import logging
from pathlib import Path
from enum import Enum

# Adiciona path para imports
sys.path.insert(0, str(Path(__file__).parent))
# Instrumenta√ß√£o Prometheus
from prometheus_client import Counter, Gauge, Histogram, start_http_server

# Slot Context System
from slot_context import init_bot_slot, labels_for_metrics, update_slot_stage

# Setup logging
logger = logging.getLogger(__name__)

# =============================================================================
# BOT STATE MANAGEMENT - FASE 3
# =============================================================================

class BotState(Enum):
    """Estados poss√≠veis do bot"""
    STOPPED = "stopped"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPING = "stopping"
    EMERGENCY_STOPPED = "emergency_stopped"

class BotMode(Enum):
    """Modos de opera√ß√£o"""
    AUTO = "auto"
    MANUAL = "manual"
    SIMULATION = "simulation"

# Estado global do bot
bot_state = BotState.STOPPED
bot_mode = BotMode.AUTO
emergency_flag = False

# FUN√á√ïES AUXILIARES ADICIONADAS
def _get_env_float(name: str, default: float) -> float:
    try:
        return float(os.getenv(name, default))
    except Exception:
        return default

def _build_redis_client():
    url = os.getenv("REDIS_URL")
    if url:
        return redis.from_url(url, decode_responses=True)
    host = os.getenv("REDIS_HOST", "redis")
    port = int(os.getenv("REDIS_PORT", "6379"))
    pwd  = os.getenv("REDIS_PASSWORD") or None
    return redis.Redis(host=host, port=port, password=pwd, decode_responses=True)

def _infer_group_from_slot(slot_id: str) -> str:
    nums = re.findall(r'\d+', slot_id or "")
    if nums:
        return "G1" if (int(nums[-1]) % 2 == 1) else "G2"
    return os.getenv("GROUP", "G1")

def _load_slot_params(instance_suffix: str = "1"):
    slot_id     = os.getenv("SLOT_ID", f"slot-{instance_suffix}")
    symbol      = os.getenv("SYMBOL", "BTC/USDT")
    base_amount = _get_env_float("BASE_AMOUNT", 10.0)
    min_amount  = _get_env_float("MIN_AMOUNT", 5.0)
    group       = os.getenv("GROUP", _infer_group_from_slot(slot_id))
    rclient     = _build_redis_client()
    return rclient, slot_id, base_amount, min_amount, group, symbol

# Prometheus metrics will be exposed via FastAPI on port 9200
# The standalone prometheus HTTP server is no longer needed as FastAPI will handle it
print("üîß Prometheus metrics will be exposed via FastAPI on port 9200...")

# Constantes para instrumenta√ß√£o
JOB = "bot"

# M√©tricas Prometheus slot-aware
TRADES = Counter(
    "trades_total", "Executed trades count",
    ["job", "slot_stage", "slot_strategy", "slot_instance"]
)

WS_LAG = Gauge(
    "ws_lag_ms", "WebSocket feed lag in milliseconds",
    ["job", "slot_stage", "slot_strategy", "slot_instance"]
)

DECIDE = Histogram(
    "decide_duration_seconds", "Decision processing time",
    ["job", "slot_stage", "slot_strategy", "slot_instance"],
    buckets=[.005, .01, .02, .05, .1, .2, .5, 1]
)

# Fun√ß√µes auxiliares para m√©tricas
def inc_trade():
    """Incrementa contador de trades executados"""
    labels = labels_for_metrics()
    TRADES.labels(JOB, **labels).inc()

def set_ws_lag(ms: float):
    """Define lag atual do WebSocket"""
    labels = labels_for_metrics()
    WS_LAG.labels(JOB, **labels).set(ms)

def observe_decide(duration: float):
    """Registra tempo de decis√£o"""
    labels = labels_for_metrics()
    DECIDE.labels(JOB, **labels).observe(duration)

# Inicializar slot context para o bot COM PAR√ÇMETROS COMPLETOS
redis_client, slot_id, base_amount, min_amount, group, symbol = _load_slot_params("1")

init_bot_slot(
    strategy="multi-agent",
    instance="bot-1",
    redis_client=redis_client,
    slot_id=slot_id,
    base_amount=base_amount,
    min_amount=min_amount,
    group=group,
    symbol=symbol,
)
print("‚úÖ Slot context inicializado para bot")

# =============================================================================
# REDIS COMMAND LISTENER - FASE 3
# =============================================================================

def redis_command_listener():
    """
    Thread que escuta comandos do Redis pub/sub
    Controla estado do bot via comandos: START, STOP, PAUSE, EMERGENCY_STOP, MODE:xxx
    """
    global bot_state, bot_mode, emergency_flag
    
    pubsub = redis_client.pubsub()
    pubsub.subscribe("bot:commands")
    
    logger.info("üéß Redis command listener started")
    
    for message in pubsub.listen():
        if message['type'] == 'message':
            command = message['data']
            logger.info(f"üì® Received command: {command}")
            
            if command == "START":
                bot_state = BotState.RUNNING
                logger.info("‚ñ∂Ô∏è Bot state changed to RUNNING")
                
            elif command == "STOP":
                bot_state = BotState.STOPPING
                logger.warning("‚èπÔ∏è Bot state changed to STOPPING - will close positions")
                close_all_positions()
                bot_state = BotState.STOPPED
                
            elif command == "PAUSE":
                bot_state = BotState.PAUSED
                logger.info("‚è∏Ô∏è Bot state changed to PAUSED - no new positions")
                
            elif command == "EMERGENCY_STOP":
                bot_state = BotState.EMERGENCY_STOPPED
                emergency_flag = True
                logger.critical("üö® EMERGENCY STOP - closing all positions NOW")
                emergency_close_all_positions()
                
            elif command.startswith("MODE:"):
                mode_str = command.split(":")[1]
                try:
                    bot_mode = BotMode(mode_str)
                    logger.info(f"üîÑ Bot mode changed to {bot_mode.value}")
                except ValueError:
                    logger.error(f"‚ùå Invalid mode received: {mode_str}")
            
            elif command.startswith("CLOSE_OPERATION:"):
                operation_id = command.split(":")[1]
                logger.warning(f"‚ö†Ô∏è Force close requested for operation: {operation_id}")
                # TODO: Implementar fechamento de opera√ß√£o espec√≠fica via Exchange Executor

# Iniciar listener em thread separada
listener_thread = threading.Thread(target=redis_command_listener, daemon=True)
listener_thread.start()
logger.info("‚úÖ Redis listener thread started")


# =============================================================================
# FUN√á√ïES DE FECHAMENTO DE POSI√á√ïES - FASE 3
# =============================================================================

def close_all_positions():
    """
    Fecha todas as posi√ß√µes abertas de forma ordenada
    
    TODO: Implementar integra√ß√£o com:
    1. Operations Logger (MongoDB) - buscar opera√ß√µes com status='open'
    2. Exchange Executor (CCXT) - enviar ordem de fechamento para cada exchange
    3. Operations Logger (MongoDB) - atualizar status para 'closed' + registro de P&L
    """
    try:
        logger.info("üîÑ Iniciando fechamento ordenado de todas as posi√ß√µes...")
        
        # Estrutura preparada para:
        # - Buscar opera√ß√µes abertas via MongoDB operations collection
        # - Iterar sobre cada opera√ß√£o e fechar via exchange correspondente
        # - Atualizar registros no banco com resultado do fechamento
        
        pass  # Aguardando implementa√ß√£o real

    except Exception as e:
        logger.error(f"‚ùå Erro ao fechar posi√ß√µes: {e}")

def emergency_close_all_positions():
    """
    Fecha todas as posi√ß√µes IMEDIATAMENTE a mercado (sem valida√ß√µes)
    
    TODO: Implementar integra√ß√£o com:
    1. Operations Logger (MongoDB) - buscar opera√ß√µes com status='open'
    2. Exchange Executor (CCXT) - enviar ordens MARKET para fechamento imediato
    3. Operations Logger (MongoDB) - atualizar status para 'closed' + flag emergency
    """
    try:
        logger.critical("üö® EMERGENCY CLOSE: Fechamento imediato de todas as posi√ß√µes")
        
        # Estrutura preparada para:
        # - Buscar opera√ß√µes abertas via MongoDB operations collection
        # - Fechar tudo a mercado sem valida√ß√µes de pre√ßo/slippage
        # - Registrar no banco com flag de fechamento emergencial
        
        pass  # Aguardando implementa√ß√£o real

    except Exception as e:
        logger.critical(f"‚ùå Erro cr√≠tico no emergency close: {e}")


# Imports da nova arquitetura
from core.engine.bot_engine import BotEngine
from config.settings.config_manager import get_config_manager
from plugins.registry.plugin_registry import get_plugin_registry

# Import do sistema original para compatibilidade TOTAL
try:
    # Importa TODAS as funcionalidades do bot original
    from bot_runner import *  # Importa tudo do sistema original
    print("[BOT_RUNNER_MODULAR] Sistema original importado com sucesso")
    LEGACY_SYSTEM_AVAILABLE = True
except ImportError as e:
    print(f"[BOT_RUNNER_MODULAR] Sistema original n√£o dispon√≠vel: {e}")
    LEGACY_SYSTEM_AVAILABLE = False


class ModularBotRunner:
    """
    Runner modular que integra com sistema original
    Executa em modo h√≠brido: nova arquitetura + compatibilidade total
    """
    
    def __init__(self):
        print("\n" + "="*80)
        print("ü§ñ BOT AI MULTI-AGENT - ARQUITETURA MODULAR v2.0")
        print("="*80)
        
        # Inicializa componentes modulares
        self.config_manager = get_config_manager()
        self.plugin_registry = get_plugin_registry()
        self.bot_engine = BotEngine()
        
        # Flags de controle
        self.use_legacy_runner = True  # Usa sistema original por padr√£o
        self.modular_enhancements = True  # Aplica melhorias modulares
        
        print("‚úÖ Arquitetura modular inicializada")
        print(f"‚úÖ Sistema legado {'dispon√≠vel' if LEGACY_SYSTEM_AVAILABLE else 'indispon√≠vel'}")
        print(f"‚úÖ Configura√ß√µes carregadas: {len(self.config_manager.get_config())} se√ß√µes")
        
        # =============================================================================
        # FASE 3 COMPONENTS INITIALIZATION
        # =============================================================================
        
        # Inicializa Risk Manager
        try:
            from risk.managers.risk_manager import RiskManager
            risk_config = {
                "max_exposure_pct": float(os.getenv("MAX_EXPOSURE_PCT", "10.0")),
                "max_open_positions": int(os.getenv("MAX_OPEN_POSITIONS", "5")),
                "max_daily_loss_pct": float(os.getenv("MAX_DAILY_LOSS_PCT", "5.0")),
                "max_loss_per_trade_pct": float(os.getenv("MAX_LOSS_PER_TRADE_PCT", "2.0")),
                "max_drawdown_pct": float(os.getenv("MAX_DRAWDOWN_PCT", "15.0")),
                "capital": float(os.getenv("INITIAL_CAPITAL", "10000.0"))
            }
            self.risk_manager = RiskManager(risk_config)
            print("‚úÖ Risk Manager inicializado")
        except Exception as e:
            print(f"‚ö†Ô∏è Risk Manager n√£o inicializado: {e}")
            self.risk_manager = None
        
        # Inicializa Exchange Executor
        try:
            from core.execution.exchange_executor import ExchangeExecutor
            self.exchange_executor = ExchangeExecutor()
            print("‚úÖ Exchange Executor inicializado")
        except Exception as e:
            print(f"‚ö†Ô∏è Exchange Executor n√£o inicializado: {e}")
            self.exchange_executor = None
        
        # Inicializa Operations Logger
        try:
            from core.logging.operations_logger import OperationsLogger
            self.operations_logger = OperationsLogger()
            print("‚úÖ Operations Logger inicializado")
        except Exception as e:
            print(f"‚ö†Ô∏è Operations Logger n√£o inicializado: {e}")
            self.operations_logger = None
        
        # Inicializa Cascade Orchestrator
        try:
            from core.engine.cascade_orchestrator import start_cascade_orchestrator
            self.cascade_orchestrator = start_cascade_orchestrator(
                check_interval_seconds=300  # 5 minutos
            )
            print("‚úÖ Cascade Orchestrator inicializado e rodando")
        except Exception as e:
            print(f"‚ö†Ô∏è Cascade Orchestrator n√£o inicializado: {e}")
            self.cascade_orchestrator = None
        
        self._initialize_plugins()
    
    def _initialize_plugins(self):
        """Inicializa sistema de plugins"""
        try:
            # Registra plugins b√°sicos de exemplo
            self._register_example_plugins()
            
            # Descobre plugins autom√°ticos se habilitado
            if self.config_manager.get('plugins.auto_discover', True):
                plugin_dirs = self.config_manager.get('plugins.directories', ['plugins/implementations'])
                for plugin_dir in plugin_dirs:
                    self.plugin_registry.discover_plugins_in_directory(plugin_dir)
            
            print("‚úÖ Sistema de plugins inicializado")
            print(f"   ‚Ä¢ Plugins dispon√≠veis: {len(self.plugin_registry.get_available_plugins())}")
            
        except Exception as e:
            print(f"‚ö†  Erro na inicializa√ß√£o de plugins: {e}")
    
    def _register_example_plugins(self):
        """Registra plugins de exemplo para demonstra√ß√£o"""
        # Aqui voc√™ registraria plugins reais quando dispon√≠veis
        # Por enquanto, apenas log de exemplo
        pass
    
    def run_hybrid_mode(self):
        """
        Executa em modo h√≠brido:
        - Sistema original para l√≥gica principal
        - Melhorias modulares como overlay
        """
        
        print("\nüöÄ INICIANDO MODO H√çBRIDO")
        print("-" * 50)
        
        if not LEGACY_SYSTEM_AVAILABLE:
            print("‚ùå Sistema original n√£o dispon√≠vel - usando apenas arquitetura modular")
            return self._run_modular_only()
        
        try:
            print("üìä Status dos componentes:")
            self._show_status()
            
            print("\nüîÑ Delegando para sistema original...")
            print("   (com melhorias modulares ativas)")
            
            # Executa o main() do sistema original
            # Isso mant√©m TODA funcionalidade existente
            main()
            
        except KeyboardInterrupt:
            print("\nüõë Interrup√ß√£o solicitada pelo usu√°rio")
            self._cleanup()
        except Exception as e:
            print(f"\n‚ùå Erro na execu√ß√£o: {e}")
            self._cleanup()
            raise
    
    def _run_modular_only(self):
        """Executa apenas com arquitetura modular (fallback)"""
        print("üîß Executando apenas arquitetura modular")
        
        # Implementa√ß√£o b√°sica para casos onde sistema original n√£o est√° dispon√≠vel
        self.bot_engine.start()
        
        try:
            while True:
                print("üí≠ Sistema modular em execu√ß√£o... (Ctrl+C para parar)")
                time.sleep(30)
                
        except KeyboardInterrupt:
            print("\nüõë Parando sistema modular...")
            self.bot_engine.stop()
    
    def _show_status(self):
        """Mostra status completo do sistema"""
        
        # Status do Config Manager
        config_status = self.config_manager.get_status()
        print(f"   ‚Ä¢ Configura√ß√µes: {config_status['total_sections']} se√ß√µes carregadas")
        
        # Status do Plugin Registry  
        plugin_status = self.plugin_registry.get_registry_status()
        print(f"   ‚Ä¢ Plugins: {plugin_status['total_registered_classes']} classes, {plugin_status['total_loaded_plugins']} carregados")
        
        # Status do Bot Engine
        engine_status = self.bot_engine.get_status()
        print(f"   ‚Ä¢ Engine: {'Rodando' if engine_status['engine']['running'] else 'Parado'}")
        
        # Mostra configura√ß√µes principais
        trading_config = self.config_manager.get_trading_config()
        print(f"   ‚Ä¢ Trading: {trading_config.get('symbol', 'N/A')} - {trading_config.get('timeframe', 'N/A')}")
        
        ai_config = self.config_manager.get_ai_config()
        print(f"   ‚Ä¢ AI Gateway: {ai_config.get('gateway_url', 'N/A')}")
        
        risk_config = self.config_manager.get_risk_config()
        print(f"   ‚Ä¢ Risk: DD m√°ximo {risk_config.get('max_drawdown_pct', 'N/A')}%")
    
    def _cleanup(self):
        """Limpeza de recursos"""
        print("\nüßπ Limpando recursos...")
        
        try:
            self.plugin_registry.cleanup_all_plugins()
            self.bot_engine.stop()
            print("‚úÖ Limpeza conclu√≠da")
        except Exception as e:
            print(f"‚ö†  Erro na limpeza: {e}")
    
    def get_modular_status(self):
        """Retorna status completo da arquitetura modular"""
        return {
            'modular_system': {
                'version': '2.0.0-modular',
                'legacy_available': LEGACY_SYSTEM_AVAILABLE,
                'hybrid_mode': self.use_legacy_runner,
                'enhancements_active': self.modular_enhancements
            },
            'config_manager': self.config_manager.get_status(),
            'plugin_registry': self.plugin_registry.get_registry_status(),
            'bot_engine': self.bot_engine.get_status()
        }


# =============================================================================
# AGENT ORCHESTRATION - PHASE 1
# FastAPI integration on same port (9200)
# =============================================================================

from fastapi import FastAPI
from fastapi.responses import PlainTextResponse
import uvicorn
import threading
import asyncio

# Import orchestration components
from core.orchestrator import agent_engine, register_agent_metrics
from core.orchestrator.router import orchestration_router

# Create FastAPI app
app = FastAPI(title="Bot AI MultiAgent", version="1.0.0")

# Mount orchestration router
app.include_router(orchestration_router)

# Health endpoint (existing compatibility)
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "ok", "service": "bot-ai-multiagent"}

# Metrics endpoint for Prometheus
@app.get("/metrics", response_class=PlainTextResponse)
async def metrics():
    """Prometheus metrics endpoint"""
    from prometheus_client import generate_latest, REGISTRY
    return generate_latest(REGISTRY)

# Metrics endpoint is already handled by prometheus_client on port 9200
# The HTTP server is started at line 57 above

def initialize_orchestration():
    """Initialize agent orchestration system"""
    try:
        print("\nüéØ Initializing Agent Orchestration (Phase 1)...")
        
        # Register metrics with Prometheus
        register_agent_metrics()
        print("‚úÖ Agent metrics registered")
        
        # Initialize agent engine
        success, message = agent_engine.initialize()
        if success:
            print(f"‚úÖ Agent Engine: {message}")
        else:
            print(f"‚ö†Ô∏è  Agent Engine: {message}")
        
        print("‚úÖ Agent Orchestration ready")
        
    except Exception as e:
        print(f"‚ùå Failed to initialize orchestration: {e}")

def run_fastapi_server():
    """Run FastAPI server in background thread"""
    try:
        # Create new event loop for this thread
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # Run uvicorn server
        config = uvicorn.Config(
            app,
            host="0.0.0.0",
            port=9200,
            log_level="info",
            access_log=False
        )
        server = uvicorn.Server(config)
        loop.run_until_complete(server.serve())
        
    except Exception as e:
        print(f"‚ùå FastAPI server error: {e}")


def show_modular_info():
    """Mostra informa√ß√µes sobre a nova arquitetura"""
    print("\n" + "="*80)
    print("üìã INFORMA√á√ïES DA ARQUITETURA MODULAR")
    print("="*80)
    print()
    print("üéØ MELHORIAS IMPLEMENTADAS:")
    print("   ‚úÖ Arquitetura modular com separa√ß√£o clara de responsabilidades")
    print("   ‚úÖ Sistema de plugins extens√≠vel")
    print("   ‚úÖ Gerenciamento centralizado de configura√ß√µes")
    print("   ‚úÖ Compatibilidade 100% com sistema existente")
    print("   ‚úÖ Estrutura preparada para expans√£o futura")
    print("   ‚úÖ Agent Orchestration (Phase 1) - Shadow mode")
    print()
    print("üìÅ NOVA ESTRUTURA DE DIRET√ìRIOS:")
    print("   ‚Ä¢ core/          - Motor principal e componentes centrais")
    print("   ‚Ä¢ core/orchestrator/ - Agent orchestration system")
    print("   ‚Ä¢ ai/            - Sistema de IA modular")
    print("   ‚Ä¢ risk/          - Gerenciamento de risco refatorado")
    print("   ‚Ä¢ plugins/       - Sistema de plugins")
    print("   ‚Ä¢ config/        - Configura√ß√µes centralizadas")
    print("   ‚Ä¢ config/agents/ - Agent YAML configurations")
    print()
    print("üîÑ MODO DE EXECU√á√ÉO:")
    print("   ‚Ä¢ H√çBRIDO: Nova arquitetura + sistema original")
    print("   ‚Ä¢ Funcionalidades existentes preservadas")
    print("   ‚Ä¢ Melhorias modulares aplicadas como overlay")
    print("   ‚Ä¢ Agent Orchestration: Shadow mode only (Phase 1)")
    print()
    print("üöÄ PR√ìXIMAS ETAPAS:")
    print("   ‚Ä¢ Etapa 2: Sistema multi-exchange")
    print("   ‚Ä¢ Etapa 3: Engine de backtesting")
    print("   ‚Ä¢ Etapa 4: Documenta√ß√£o e comunidade")
    print("="*80)


def main():
    """Fun√ß√£o principal - mant√©m compatibilidade"""
    
    # Verifica se deve mostrar info da arquitetura
    if len(sys.argv) > 1 and sys.argv[1] == '--modular-info':
        show_modular_info()
        return
    
    # Initialize Agent Orchestration (Phase 1)
    initialize_orchestration()
    
    # Start FastAPI server in background thread
    print("üöÄ Starting FastAPI server on port 9200...")
    fastapi_thread = threading.Thread(target=run_fastapi_server, daemon=True)
    fastapi_thread.start()
    print("‚úÖ FastAPI server started (background)")
    
    # Give FastAPI a moment to start
    time.sleep(2)
    
    # Modo padr√£o: execu√ß√£o h√≠brida
    try:
        runner = ModularBotRunner()
        runner.run_hybrid_mode()
        
    except Exception as e:
        print(f"\nüí• Erro cr√≠tico: {e}")
        
        # Se falhar, tenta executar sistema original diretamente
        if LEGACY_SYSTEM_AVAILABLE:
            print("üîÑ Tentando fallback para sistema original...")
            try:
                # Chama main() original diretamente
                import bot_runner
                bot_runner.main()
            except Exception as fallback_error:
                print(f"‚ùå Fallback tamb√©m falhou: {fallback_error}")
                sys.exit(1)
        else:
            sys.exit(1)


if __name__ == "__main__":
    main()