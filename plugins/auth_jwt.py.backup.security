#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
JWT Auth Plugin - Bot AI Trading
Sistema de autentica√ß√£o JWT com hash de senhas
"""

import os
import logging
from typing import Dict, Any, Optional, Union
from datetime import datetime, timedelta
import jwt
from passlib.context import CryptContext
from fastapi import HTTPException, Depends, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
from .base.plugin_interface import IPlugin

logger = logging.getLogger(__name__)

# Models
class TokenData(BaseModel):
    """Dados do token JWT"""
    username: str
    user_id: str
    roles: list = []
    exp: datetime

class UserCredentials(BaseModel):
    """Credenciais de usu√°rio"""
    username: str
    password: str

class TokenResponse(BaseModel):
    """Resposta de token"""
    access_token: str
    token_type: str = "bearer"
    expires_in: int
    user_info: dict

class JWTAuthPlugin(IPlugin):
    """
    Plugin de Autentica√ß√£o JWT
    """
    
    def __init__(self):
        """Inicializa o plugin de autentica√ß√£o"""
        self.name = "JWTAuthPlugin"
        self.version = "1.0.0"
        self.description = "Sistema de autentica√ß√£o JWT com hash de senhas"
        self.enabled = True
        self.secret_key = None
        self.algorithm = "HS256"
        self.token_expire_minutes = 30
        # Initialize pwd_context with better error handling
        try:
            # Try bcrypt first
            self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
            # Test it with a short password
            test_hash = self.pwd_context.hash("test")
            self.pwd_context.verify("test", test_hash)
            logger.info("‚úÖ BCrypt context initialized successfully")
        except Exception as e:
            logger.warning(f"BCrypt context failed, using PBKDF2: {e}")
            # Fallback to PBKDF2 which is more reliable
            self.pwd_context = CryptContext(schemes=["pbkdf2_sha256"], deprecated="auto")
        self.security = HTTPBearer()
        
        # Database simulado de usu√°rios (em produ√ß√£o seria BD real)
        self.users_db = {}
        
        logger.info(f"üîê {self.name} v{self.version} initialized")
    
    def get_info(self) -> Dict[str, Any]:
        """Retorna informa√ß√µes do plugin"""
        return {
            "name": self.name,
            "version": self.version,
            "description": self.description,
            "enabled": self.enabled,
            "type": "authentication",
            "dependencies": ["pyjwt", "passlib[bcrypt]", "fastapi"],
            "config": {
                "algorithm": self.algorithm,
                "token_expire_minutes": self.token_expire_minutes,
                "require_auth": True
            }
        }
    
    def initialize(self, config: Optional[Dict[str, Any]] = None) -> bool:
        """Inicializa o sistema de autentica√ß√£o"""
        
        try:
            # Configura√ß√£o padr√£o
            default_config = {
                "secret_key": os.getenv("API_SECRET_KEY", "botai_secret_key_2025")[:64],  # Limit to 64 chars
                "algorithm": "HS256",
                "token_expire_minutes": 30,
                "require_auth": True
            }
            
            if config:
                default_config.update(config)
            
            self.secret_key = default_config["secret_key"]
            self.algorithm = default_config["algorithm"]
            self.token_expire_minutes = default_config["token_expire_minutes"]
            self.config = default_config
            
            # Criar usu√°rios padr√£o (em produ√ß√£o seria do BD)
            self._create_default_users()
            
            logger.info("‚úÖ JWT authentication system initialized")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error initializing JWT auth: {e}")
            return False
    
    def _create_default_users(self):
        """Cria usu√°rios padr√£o para o sistema"""
        
        default_users = [
            {
                "username": "admin",
                "password": "admin123",
                "roles": ["admin", "trader"],
                "user_id": "1"
            },
            {
                "username": "trader",
                "password": "trader123", 
                "roles": ["trader"],
                "user_id": "2"
            },
            {
                "username": "viewer",
                "password": "viewer123",
                "roles": ["viewer"],
                "user_id": "3"
            }
        ]
        
        for user in default_users:
            hashed_password = self.get_password_hash(user["password"])
            self.users_db[user["username"]] = {
                "username": user["username"],
                "hashed_password": hashed_password,
                "roles": user["roles"],
                "user_id": user["user_id"],
                "created_at": datetime.now().isoformat(),
                "active": True
            }
        
        logger.info(f"üë• Created {len(default_users)} default users")
    
    def get_password_hash(self, password: str) -> str:
        """Gera hash da senha"""
        # Truncate password to 72 bytes for bcrypt compatibility
        if len(password.encode('utf-8')) > 72:
            password = password.encode('utf-8')[:72].decode('utf-8', errors='ignore')
        return self.pwd_context.hash(password)
    
    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """Verifica senha"""
        return self.pwd_context.verify(plain_password, hashed_password)
    
    def authenticate_user(self, username: str, password: str) -> Union[Dict[str, Any], None]:
        """Autentica usu√°rio"""
        
        user = self.users_db.get(username)
        if not user:
            return None
        
        if not self.verify_password(password, user["hashed_password"]):
            return None
        
        return user
    
    def create_access_token(self, data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
        """Cria token de acesso"""
        
        to_encode = data.copy()
        
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=self.token_expire_minutes)
        
        to_encode.update({"exp": expire})
        
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt
    
    def verify_token(self, token: str) -> Union[TokenData, None]:
        """Verifica e decodifica token"""
        
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            username: str = payload.get("sub")
            
            if username is None:
                return None
            
            token_data = TokenData(
                username=username,
                user_id=payload.get("user_id", ""),
                roles=payload.get("roles", []),
                exp=datetime.fromtimestamp(payload.get("exp"))
            )
            
            return token_data
            
        except jwt.ExpiredSignatureError:
            logger.warning("Token expired")
            return None
        except jwt.JWTError as e:
            logger.warning(f"JWT error: {e}")
            return None
    
    def login(self, credentials: UserCredentials) -> Union[TokenResponse, None]:
        """Realiza login e retorna token"""
        
        try:
            user = self.authenticate_user(credentials.username, credentials.password)
            if not user:
                return None
            
            # Criar dados do token
            token_data = {
                "sub": user["username"],
                "user_id": user["user_id"],
                "roles": user["roles"]
            }
            
            # Criar token
            access_token_expires = timedelta(minutes=self.token_expire_minutes)
            access_token = self.create_access_token(
                data=token_data,
                expires_delta=access_token_expires
            )
            
            return TokenResponse(
                access_token=access_token,
                expires_in=self.token_expire_minutes * 60,
                user_info={
                    "username": user["username"],
                    "user_id": user["user_id"],
                    "roles": user["roles"]
                }
            )
            
        except Exception as e:
            logger.error(f"Login error: {e}")
            return None
    
    def get_current_user(self, credentials: HTTPAuthorizationCredentials = Depends(HTTPBearer())):
        """Dependency para obter usu√°rio atual"""
        
        try:
            token_data = self.verify_token(credentials.credentials)
            
            if token_data is None:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Could not validate credentials",
                    headers={"WWW-Authenticate": "Bearer"}
                )
            
            user = self.users_db.get(token_data.username)
            if user is None:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="User not found"
                )
            
            return user
            
        except Exception as e:
            logger.error(f"Authentication error: {e}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Authentication failed"
            )
    
    def require_roles(self, required_roles: list):
        """Dependency para verificar roles"""
        
        def role_checker(current_user: dict = Depends(self.get_current_user)):
            user_roles = current_user.get("roles", [])
            
            if not any(role in user_roles for role in required_roles):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Insufficient permissions"
                )
            
            return current_user
        
        return role_checker
    
    def create_user(self, username: str, password: str, roles: list = None, user_id: str = None) -> bool:
        """Cria novo usu√°rio"""
        
        try:
            if username in self.users_db:
                logger.warning(f"User {username} already exists")
                return False
            
            if roles is None:
                roles = ["viewer"]
            
            if user_id is None:
                user_id = str(len(self.users_db) + 1)
            
            hashed_password = self.get_password_hash(password)
            
            self.users_db[username] = {
                "username": username,
                "hashed_password": hashed_password,
                "roles": roles,
                "user_id": user_id,
                "created_at": datetime.now().isoformat(),
                "active": True
            }
            
            logger.info(f"‚úÖ User {username} created successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error creating user: {e}")
            return False
    
    def execute(self) -> Dict[str, Any]:
        """Executa verifica√ß√µes do sistema de autentica√ß√£o"""
        
        try:
            status = {
                "plugin": self.name,
                "timestamp": datetime.now().isoformat(),
                "auth_enabled": self.enabled,
                "users_count": len(self.users_db),
                "token_expire_minutes": self.token_expire_minutes,
                "algorithm": self.algorithm
            }
            
            # Estat√≠sticas de usu√°rios
            active_users = sum(1 for user in self.users_db.values() if user.get("active", True))
            roles_summary = {}
            
            for user in self.users_db.values():
                for role in user.get("roles", []):
                    roles_summary[role] = roles_summary.get(role, 0) + 1
            
            status.update({
                "active_users": active_users,
                "roles_summary": roles_summary,
                "security_status": "active"
            })
            
            return status
            
        except Exception as e:
            logger.error(f"Error executing auth checks: {e}")
            return {
                "plugin": self.name,
                "status": "error",
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }
    
    def shutdown(self) -> bool:
        """Shutdown do plugin"""
        
        try:
            # Limpar dados sens√≠veis da mem√≥ria
            self.users_db.clear()
            self.secret_key = None
            
            logger.info(f"üõë {self.name} shutdown completed")
            return True
            
        except Exception as e:
            logger.error(f"Error during shutdown: {e}")
            return False

# Inst√¢ncia global do plugin
jwt_auth_plugin = JWTAuthPlugin()

# Utilit√°rios de conveni√™ncia
def setup_jwt_auth(config: Optional[Dict[str, Any]] = None):
    """Setup r√°pido de JWT auth"""
    return jwt_auth_plugin.initialize(config)

def get_current_user():
    """Dependency para obter usu√°rio atual"""
    return jwt_auth_plugin.get_current_user

def require_roles(roles: list):
    """Dependency para verificar roles"""
    return jwt_auth_plugin.require_roles(roles)

def create_token(username: str, password: str) -> Union[TokenResponse, None]:
    """Cria token para credenciais"""
    credentials = UserCredentials(username=username, password=password)
    return jwt_auth_plugin.login(credentials)